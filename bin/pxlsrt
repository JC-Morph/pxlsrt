#!/usr/bin/env ruby

require 'pxlsrt'
require 'thor'

# Thor command-line class. Universal options:
# * reverse  - Reverses the bands or randomly reverses or doesn't reverse.
# * vertical - Sorts vertically.
# * diagonal - Sorts diagonally. Use with vertical to change orientation.
# * smooth   - "Smoothes" sorted values by grouping identical pixels together.
# * method   - What method to use to sort pixels.
# * verbose  - Have pxlsrt tell you what it's working on.
# * help     - More in depth commands.
class CLI < Thor
  class_option :verbose, type: :boolean, default: false, aliases: '-V'

  METHODS = Pxlsrt::Colors::METHODS

  class << self
    def bool
      @bool ||= {type: :boolean, default: false}
    end

    def infinite
      @infinite ||= {type: :numeric, default: Float::INFINITY}
    end

    def common_options
      option :reverse, aliases: '-r', **bool
      option :smooth,  aliases: '-s', **bool
      option :middle,  aliases: '-M', check_default_type: false, default: false
      option :method,
        aliases: '-m',
        type:    :string,
        default: 'sum-rgb',
        enum:    METHODS,
        banner:  "[#{METHODS.join(' | ')}]"
    end

    def axis_options
      option :vertical, aliases: '-v', **bool
      option :diagonal, aliases: '-d', **bool
    end
  end

  common_options
  axis_options
  option :min, banner: 'MINIMUM BANDWIDTH', **infinite
  option :max, banner: 'MAXIMUM BANDWIDTH', **infinite
  desc 'brute INPUT OUTPUT [options]', 'Brute pixel sorting'
  # Specific options:
  # * min - Minimum bandwidth.
  # * max - Maximum bandwidth.
  def brute(input, output)
    k = { trusted: true }
    options.each_key do |o|
      k[o.to_sym] = options[o]
    end
    Pxlsrt::Brute.suite(input, output, k)
  end

  common_options
  axis_options
  option :absolute,  aliases: '-a', banner: 'ABSOLUTE EDGE FINDING', **bool
  option :threshold, aliases: '-t', type: :numeric, default: 20
  desc 'smart INPUT OUTPUT [options]', 'Smart pixel sorting'
  # Specific options:
  # * threshold - Number used in edge finding. Specifics explained under
  #               "absolute".
  # * absolute  - Make edge finding absolute over relative. For example, define
  #               a range as a collection of values under the threshold.
  #               Relative edge finding is when the contrast of the next pixel
  #               is larger than the threshold.
  def smart(input, output)
    k = { trusted: true }
    options.each_key do |o|
      k[o.to_sym] = options[o]
    end
    Pxlsrt::Smart.suite(input, output, k)
  end

  option :value,  aliases: '-v', type: :numeric
  option :method,
    aliases: '-m',
    type:    :string,
    default: 'brightness',
    enum:    %w(brightness white black)
  desc 'kim INPUT OUTPUT [options]', "Uses Kim Asendorf's algorithm"
  def kim(input, output)
    k = { trusted: true }
    options.each_key do |o|
      k[o.to_sym] = options[o]
    end
    Pxlsrt::Kim.suite(input, output, k)
  end

  common_options
  option :random,    aliases: '-R', **bool
  option :distance,  aliases: '-d', type: :numeric, default: 100
  option :threshold, aliases: '-t', type: :numeric, default: 0.1
  desc 'seed INPUT OUTPUT [options]', 'Seed pixel sorting'
  def seed(input, output)
    k = { trusted: true }
    options.each_key do |o|
      k[o.to_sym] = options[o]
    end
    k[:random] = Pxlsrt::Helpers.isNumeric?(k[:random]) ? k[:random].to_i : false
    k[:distance] = Pxlsrt::Helpers.isNumeric?(k[:distance]) ? k[:distance].to_i : false
    Pxlsrt::Seed.suite(input, output, k)
  end
end

CLI.start(ARGV)
